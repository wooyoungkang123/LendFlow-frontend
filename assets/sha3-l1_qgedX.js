var p={},E={},X;function K(){if(X)return E;X=1,Object.defineProperty(E,"__esModule",{value:!0}),E.anumber=s,E.abytes=w,E.ahash=A,E.aexists=S,E.aoutput=O;function s(l){if(!Number.isSafeInteger(l)||l<0)throw new Error("positive integer expected, got "+l)}function b(l){return l instanceof Uint8Array||ArrayBuffer.isView(l)&&l.constructor.name==="Uint8Array"}function w(l,..._){if(!b(l))throw new Error("Uint8Array expected");if(_.length>0&&!_.includes(l.length))throw new Error("Uint8Array expected of length "+_+", got length="+l.length)}function A(l){if(typeof l!="function"||typeof l.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");s(l.outputLen),s(l.blockLen)}function S(l,_=!0){if(l.destroyed)throw new Error("Hash instance has been destroyed");if(_&&l.finished)throw new Error("Hash#digest() has already been called")}function O(l,_){w(l);const m=_.outputLen;if(l.length<m)throw new Error("digestInto() expects output buffer of length at least "+m)}return E}var c={},V;function G(){if(V)return c;V=1,Object.defineProperty(c,"__esModule",{value:!0}),c.add5L=c.add5H=c.add4H=c.add4L=c.add3H=c.add3L=c.rotlBL=c.rotlBH=c.rotlSL=c.rotlSH=c.rotr32L=c.rotr32H=c.rotrBL=c.rotrBH=c.rotrSL=c.rotrSH=c.shrSL=c.shrSH=c.toBig=void 0,c.fromBig=w,c.split=A,c.add=H;const s=BigInt(2**32-1),b=BigInt(32);function w(n,e=!1){return e?{h:Number(n&s),l:Number(n>>b&s)}:{h:Number(n>>b&s)|0,l:Number(n&s)|0}}function A(n,e=!1){let r=new Uint32Array(n.length),t=new Uint32Array(n.length);for(let o=0;o<n.length;o++){const{h:f,l:d}=w(n[o],e);[r[o],t[o]]=[f,d]}return[r,t]}const S=(n,e)=>BigInt(n>>>0)<<b|BigInt(e>>>0);c.toBig=S;const O=(n,e,r)=>n>>>r;c.shrSH=O;const l=(n,e,r)=>n<<32-r|e>>>r;c.shrSL=l;const _=(n,e,r)=>n>>>r|e<<32-r;c.rotrSH=_;const m=(n,e,r)=>n<<32-r|e>>>r;c.rotrSL=m;const x=(n,e,r)=>n<<64-r|e>>>r-32;c.rotrBH=x;const j=(n,e,r)=>n>>>r-32|e<<64-r;c.rotrBL=j;const T=(n,e)=>e;c.rotr32H=T;const F=(n,e)=>n;c.rotr32L=F;const q=(n,e,r)=>n<<r|e>>>32-r;c.rotlSH=q;const k=(n,e,r)=>e<<r|n>>>32-r;c.rotlSL=k;const I=(n,e,r)=>e<<r-32|n>>>64-r;c.rotlBH=I;const v=(n,e,r)=>n<<r-32|e>>>64-r;c.rotlBL=v;function H(n,e,r,t){const o=(e>>>0)+(t>>>0);return{h:n+r+(o/2**32|0)|0,l:o|0}}const B=(n,e,r)=>(n>>>0)+(e>>>0)+(r>>>0);c.add3L=B;const U=(n,e,r,t)=>e+r+t+(n/2**32|0)|0;c.add3H=U;const a=(n,e,r,t)=>(n>>>0)+(e>>>0)+(r>>>0)+(t>>>0);c.add4L=a;const i=(n,e,r,t,o)=>e+r+t+o+(n/2**32|0)|0;c.add4H=i;const u=(n,e,r,t,o)=>(n>>>0)+(e>>>0)+(r>>>0)+(t>>>0)+(o>>>0);c.add5L=u;const h=(n,e,r,t,o,f)=>e+r+t+o+f+(n/2**32|0)|0;c.add5H=h;const y={fromBig:w,split:A,toBig:S,shrSH:O,shrSL:l,rotrSH:_,rotrSL:m,rotrBH:x,rotrBL:j,rotr32H:T,rotr32L:F,rotlSH:q,rotlSL:k,rotlBH:I,rotlBL:v,add:H,add3L:B,add3H:U,add4L:a,add4H:i,add5H:h,add5L:u};return c.default=y,c}var R={},C={},N;function J(){return N||(N=1,Object.defineProperty(C,"__esModule",{value:!0}),C.crypto=void 0,C.crypto=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0),C}var W;function Q(){return W||(W=1,function(s){/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */Object.defineProperty(s,"__esModule",{value:!0}),s.Hash=s.nextTick=s.byteSwapIfBE=s.isLE=void 0,s.isBytes=A,s.u8=S,s.u32=O,s.createView=l,s.rotr=_,s.rotl=m,s.byteSwap=x,s.byteSwap32=j,s.bytesToHex=q,s.hexToBytes=v,s.asyncLoop=B,s.utf8ToBytes=U,s.toBytes=a,s.concatBytes=i,s.checkOpts=h,s.wrapConstructor=y,s.wrapConstructorWithOpts=n,s.wrapXOFConstructorWithOpts=e,s.randomBytes=r;const b=J(),w=K();function A(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function S(t){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}function O(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))}function l(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function _(t,o){return t<<32-o|t>>>o}function m(t,o){return t<<o|t>>>32-o>>>0}s.isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function x(t){return t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255}s.byteSwapIfBE=s.isLE?t=>t:t=>x(t);function j(t){for(let o=0;o<t.length;o++)t[o]=x(t[o])}const T=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",F=Array.from({length:256},(t,o)=>o.toString(16).padStart(2,"0"));function q(t){if((0,w.abytes)(t),T)return t.toHex();let o="";for(let f=0;f<t.length;f++)o+=F[t[f]];return o}const k={_0:48,_9:57,A:65,F:70,a:97,f:102};function I(t){if(t>=k._0&&t<=k._9)return t-k._0;if(t>=k.A&&t<=k.F)return t-(k.A-10);if(t>=k.a&&t<=k.f)return t-(k.a-10)}function v(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(T)return Uint8Array.fromHex(t);const o=t.length,f=o/2;if(o%2)throw new Error("hex string expected, got unpadded hex of length "+o);const d=new Uint8Array(f);for(let g=0,L=0;g<f;g++,L+=2){const M=I(t.charCodeAt(L)),P=I(t.charCodeAt(L+1));if(M===void 0||P===void 0){const z=t[L]+t[L+1];throw new Error('hex string expected, got non-hex character "'+z+'" at index '+L)}d[g]=M*16+P}return d}const H=async()=>{};s.nextTick=H;async function B(t,o,f){let d=Date.now();for(let g=0;g<t;g++){f(g);const L=Date.now()-d;L>=0&&L<o||(await(0,s.nextTick)(),d+=L)}}function U(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array(new TextEncoder().encode(t))}function a(t){return typeof t=="string"&&(t=U(t)),(0,w.abytes)(t),t}function i(...t){let o=0;for(let d=0;d<t.length;d++){const g=t[d];(0,w.abytes)(g),o+=g.length}const f=new Uint8Array(o);for(let d=0,g=0;d<t.length;d++){const L=t[d];f.set(L,g),g+=L.length}return f}class u{clone(){return this._cloneInto()}}s.Hash=u;function h(t,o){if(o!==void 0&&{}.toString.call(o)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(t,o)}function y(t){const o=d=>t().update(a(d)).digest(),f=t();return o.outputLen=f.outputLen,o.blockLen=f.blockLen,o.create=()=>t(),o}function n(t){const o=(d,g)=>t(g).update(a(d)).digest(),f=t({});return o.outputLen=f.outputLen,o.blockLen=f.blockLen,o.create=d=>t(d),o}function e(t){const o=(d,g)=>t(g).update(a(d)).digest(),f=t({});return o.outputLen=f.outputLen,o.blockLen=f.blockLen,o.create=d=>t(d),o}function r(t=32){if(b.crypto&&typeof b.crypto.getRandomValues=="function")return b.crypto.getRandomValues(new Uint8Array(t));if(b.crypto&&typeof b.crypto.randomBytes=="function")return Uint8Array.from(b.crypto.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}}(R)),R}var D;function Y(){if(D)return p;D=1,Object.defineProperty(p,"__esModule",{value:!0}),p.shake256=p.shake128=p.keccak_512=p.keccak_384=p.keccak_256=p.keccak_224=p.sha3_512=p.sha3_384=p.sha3_256=p.sha3_224=p.Keccak=void 0,p.keccakP=v;const s=K(),b=G(),w=Q(),A=[],S=[],O=[],l=BigInt(0),_=BigInt(1),m=BigInt(2),x=BigInt(7),j=BigInt(256),T=BigInt(113);for(let a=0,i=_,u=1,h=0;a<24;a++){[u,h]=[h,(2*u+3*h)%5],A.push(2*(5*h+u)),S.push((a+1)*(a+2)/2%64);let y=l;for(let n=0;n<7;n++)i=(i<<_^(i>>x)*T)%j,i&m&&(y^=_<<(_<<BigInt(n))-_);O.push(y)}const[F,q]=(0,b.split)(O,!0),k=(a,i,u)=>u>32?(0,b.rotlBH)(a,i,u):(0,b.rotlSH)(a,i,u),I=(a,i,u)=>u>32?(0,b.rotlBL)(a,i,u):(0,b.rotlSL)(a,i,u);function v(a,i=24){const u=new Uint32Array(10);for(let h=24-i;h<24;h++){for(let e=0;e<10;e++)u[e]=a[e]^a[e+10]^a[e+20]^a[e+30]^a[e+40];for(let e=0;e<10;e+=2){const r=(e+8)%10,t=(e+2)%10,o=u[t],f=u[t+1],d=k(o,f,1)^u[r],g=I(o,f,1)^u[r+1];for(let L=0;L<50;L+=10)a[e+L]^=d,a[e+L+1]^=g}let y=a[2],n=a[3];for(let e=0;e<24;e++){const r=S[e],t=k(y,n,r),o=I(y,n,r),f=A[e];y=a[f],n=a[f+1],a[f]=t,a[f+1]=o}for(let e=0;e<50;e+=10){for(let r=0;r<10;r++)u[r]=a[e+r];for(let r=0;r<10;r++)a[e+r]^=~u[(r+2)%10]&u[(r+4)%10]}a[0]^=F[h],a[1]^=q[h]}u.fill(0)}class H extends w.Hash{constructor(i,u,h,y=!1,n=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=i,this.suffix=u,this.outputLen=h,this.enableXOF=y,this.rounds=n,(0,s.anumber)(h),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,w.u32)(this.state)}keccak(){w.isLE||(0,w.byteSwap32)(this.state32),v(this.state32,this.rounds),w.isLE||(0,w.byteSwap32)(this.state32),this.posOut=0,this.pos=0}update(i){(0,s.aexists)(this);const{blockLen:u,state:h}=this;i=(0,w.toBytes)(i);const y=i.length;for(let n=0;n<y;){const e=Math.min(u-this.pos,y-n);for(let r=0;r<e;r++)h[this.pos++]^=i[n++];this.pos===u&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:i,suffix:u,pos:h,blockLen:y}=this;i[h]^=u,(u&128)!==0&&h===y-1&&this.keccak(),i[y-1]^=128,this.keccak()}writeInto(i){(0,s.aexists)(this,!1),(0,s.abytes)(i),this.finish();const u=this.state,{blockLen:h}=this;for(let y=0,n=i.length;y<n;){this.posOut>=h&&this.keccak();const e=Math.min(h-this.posOut,n-y);i.set(u.subarray(this.posOut,this.posOut+e),y),this.posOut+=e,y+=e}return i}xofInto(i){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(i)}xof(i){return(0,s.anumber)(i),this.xofInto(new Uint8Array(i))}digestInto(i){if((0,s.aoutput)(i,this),this.finished)throw new Error("digest() was already called");return this.writeInto(i),this.destroy(),i}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(i){const{blockLen:u,suffix:h,outputLen:y,rounds:n,enableXOF:e}=this;return i||(i=new H(u,h,y,e,n)),i.state32.set(this.state32),i.pos=this.pos,i.posOut=this.posOut,i.finished=this.finished,i.rounds=n,i.suffix=h,i.outputLen=y,i.enableXOF=e,i.destroyed=this.destroyed,i}}p.Keccak=H;const B=(a,i,u)=>(0,w.wrapConstructor)(()=>new H(i,a,u));p.sha3_224=B(6,144,224/8),p.sha3_256=B(6,136,256/8),p.sha3_384=B(6,104,384/8),p.sha3_512=B(6,72,512/8),p.keccak_224=B(1,144,224/8),p.keccak_256=B(1,136,256/8),p.keccak_384=B(1,104,384/8),p.keccak_512=B(1,72,512/8);const U=(a,i,u)=>(0,w.wrapXOFConstructorWithOpts)((h={})=>new H(i,a,h.dkLen===void 0?u:h.dkLen,!0));return p.shake128=U(31,168,128/8),p.shake256=U(31,136,256/8),p}export{Q as a,K as b,G as c,Y as r};
